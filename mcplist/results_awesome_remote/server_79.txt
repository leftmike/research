NAME: OpenZeppelin Solidity
URL: https://mcp.openzeppelin.com/contracts/solidity/mcp
TRANSPORT: streamable-http
AUTH_REQUIRED: no
STATUS: success
EXIT_CODE: 0
OUTPUT:
{
  "tools": [
    {
      "description": "Make a fungible token per the ERC-20 standard.\n\nReturns the source code of the generated contract, formatted in a Markdown code block. Does not write to disk.",
      "inputSchema": {
        "$schema": "http://json-schema.org/draft-07/schema#",
        "properties": {
          "access": {
            "anyOf": [
              {
                "anyOf": [
                  {
                    "const": "ownable",
                    "type": "string"
                  },
                  {
                    "const": "roles",
                    "type": "string"
                  }
                ]
              },
              {
                "const": "managed",
                "type": "string"
              }
            ],
            "description": "The type of access control to provision. Ownable is a simple mechanism with a single account authorized for all privileged actions. Roles is a flexible mechanism with a separate role for each privileged action. A role can have many authorized accounts. Managed enables a central contract to define a policy that allows certain callers to access certain functions."
          },
          "burnable": {
            "description": "Whether token holders will be able to destroy their tokens",
            "type": "boolean"
          },
          "callback": {
            "description": "Whether to include support for code execution after transfers and approvals on recipient contracts in a single transaction.",
            "type": "boolean"
          },
          "crossChainBridging": {
            "anyOf": [
              {
                "const": "custom",
                "type": "string"
              },
              {
                "const": "superchain",
                "type": "string"
              }
            ],
            "description": "Whether to allow authorized bridge contracts to mint and burn tokens for cross-chain transfers. Options are to use custom bridges on any chain, or the SuperchainERC20 standard with the predeployed SuperchainTokenBridge. The SuperchainERC20 feature is only available on chains in the Superchain, and requires deploying your contract to the same address on every chain in the Superchain."
          },
          "flashmint": {
            "description": "Whether to include built-in flash loans to allow lending tokens without requiring collateral as long as they're returned in the same transaction.",
            "type": "boolean"
          },
          "info": {
            "description": "Metadata about the contract and author",
            "properties": {
              "license": {
                "description": "The license used by the contract, default is \"MIT\"",
                "type": "string"
              },
              "securityContact": {
                "description": "Email where people can contact you to report security issues. Will only be visible if contract source code is verified.",
                "type": "string"
              }
            },
            "type": "object"
          },
          "mintable": {
            "description": "Whether privileged accounts will be able to create more supply or emit more tokens",
            "type": "boolean"
          },
          "name": {
            "description": "The name of the contract",
            "type": "string"
          },
          "namespacePrefix": {
            "description": "The prefix for ERC-7201 namespace identifiers. It should be derived from the project name or a unique naming convention specific to the project. Used only if the contract includes storage variables and upgradeability is enabled. Default is \"myProject\".",
            "type": "string"
          },
          "pausable": {
            "description": "Whether privileged accounts will be able to pause specifically marked functionality. Useful for emergency response.",
            "type": "boolean"
          },
          "permit": {
            "description": "Whether without paying gas, token holders will be able to allow third parties to transfer from their account.",
            "type": "boolean"
          },
          "premint": {
            "description": "The number of tokens to premint for the deployer.",
            "type": "string"
          },
          "premintChainId": {
            "description": "The chain ID of the network on which to premint tokens.",
            "type": "string"
          },
          "symbol": {
            "description": "The short symbol for the token",
            "type": "string"
          },
          "upgradeable": {
            "anyOf": [
              {
                "const": "transparent",
                "type": "string"
              },
              {
                "const": "uups",
                "type": "string"
              }
            ],
            "description": "Whether the smart contract is upgradeable. Transparent uses more complex proxy with higher overhead, requires less changes in your contract. Can also be used with beacons. UUPS uses simpler proxy with less overhead, requires including extra code in your contract. Allows flexibility for authorizing upgrades."
          },
          "votes": {
            "anyOf": [
              {
                "const": "blocknumber",
                "type": "string"
              },
              {
                "const": "timestamp",
                "type": "string"
              }
            ],
            "description": "Whether to keep track of historical balances for voting in on-chain governance. Voting durations can be expressed as block numbers or timestamps."
          }
        },
        "required": [
          "name",
          "symbol"
        ],
        "type": "object"
      },
      "name": "solidity-erc20"
    },
    {
      "description": "Make a non-fungible token per the ERC-721 standard.\n\nReturns the source code of the generated contract, formatted in a Markdown code block. Does not write to disk.",
      "inputSchema": {
        "$schema": "http://json-schema.org/draft-07/schema#",
        "properties": {
          "access": {
            "anyOf": [
              {
                "anyOf": [
                  {
                    "const": "ownable",
                    "type": "string"
                  },
                  {
                    "const": "roles",
                    "type": "string"
                  }
                ]
              },
              {
                "const": "managed",
                "type": "string"
              }
            ],
            "description": "The type of access control to provision. Ownable is a simple mechanism with a single account authorized for all privileged actions. Roles is a flexible mechanism with a separate role for each privileged action. A role can have many authorized accounts. Managed enables a central contract to define a policy that allows certain callers to access certain functions."
          },
          "baseUri": {
            "description": "A base uri for the token",
            "type": "string"
          },
          "burnable": {
            "description": "Whether token holders will be able to destroy their tokens",
            "type": "boolean"
          },
          "enumerable": {
            "description": "Whether to allow on-chain enumeration of all tokens or those owned by an account. Increases gas cost of transfers.",
            "type": "boolean"
          },
          "incremental": {
            "description": "Whether new tokens will be automatically assigned an incremental id",
            "type": "boolean"
          },
          "info": {
            "description": "Metadata about the contract and author",
            "properties": {
              "license": {
                "description": "The license used by the contract, default is \"MIT\"",
                "type": "string"
              },
              "securityContact": {
                "description": "Email where people can contact you to report security issues. Will only be visible if contract source code is verified.",
                "type": "string"
              }
            },
            "type": "object"
          },
          "mintable": {
            "description": "Whether privileged accounts will be able to create more supply or emit more tokens",
            "type": "boolean"
          },
          "name": {
            "description": "The name of the contract",
            "type": "string"
          },
          "namespacePrefix": {
            "description": "The prefix for ERC-7201 namespace identifiers. It should be derived from the project name or a unique naming convention specific to the project. Used only if the contract includes storage variables and upgradeability is enabled. Default is \"myProject\".",
            "type": "string"
          },
          "pausable": {
            "description": "Whether privileged accounts will be able to pause specifically marked functionality. Useful for emergency response.",
            "type": "boolean"
          },
          "symbol": {
            "description": "The short symbol for the token",
            "type": "string"
          },
          "upgradeable": {
            "anyOf": [
              {
                "const": "transparent",
                "type": "string"
              },
              {
                "const": "uups",
                "type": "string"
              }
            ],
            "description": "Whether the smart contract is upgradeable. Transparent uses more complex proxy with higher overhead, requires less changes in your contract. Can also be used with beacons. UUPS uses simpler proxy with less overhead, requires including extra code in your contract. Allows flexibility for authorizing upgrades."
          },
          "uriStorage": {
            "description": "Allows updating token URIs for individual token IDs",
            "type": "boolean"
          },
          "votes": {
            "anyOf": [
              {
                "const": "blocknumber",
                "type": "string"
              },
              {
                "const": "timestamp",
                "type": "string"
              }
            ],
            "description": "Whether to keep track of individual units for voting in on-chain governance. Voting durations can be expressed as block numbers or timestamps (defaulting to block number if not specified)."
          }
        },
        "required": [
          "name",
          "symbol"
        ],
        "type": "object"
      },
      "name": "solidity-erc721"
    },
    {
      "description": "Make a non-fungible token per the ERC-1155 standard.\n\nReturns the source code of the generated contract, formatted in a Markdown code block. Does not write to disk.",
      "inputSchema": {
        "$schema": "http://json-schema.org/draft-07/schema#",
        "properties": {
          "access": {
            "anyOf": [
              {
                "anyOf": [
                  {
                    "const": "ownable",
                    "type": "string"
                  },
                  {
                    "const": "roles",
                    "type": "string"
                  }
                ]
              },
              {
                "const": "managed",
                "type": "string"
              }
            ],
            "description": "The type of access control to provision. Ownable is a simple mechanism with a single account authorized for all privileged actions. Roles is a flexible mechanism with a separate role for each privileged action. A role can have many authorized accounts. Managed enables a central contract to define a policy that allows certain callers to access certain functions."
          },
          "burnable": {
            "description": "Whether token holders will be able to destroy their tokens",
            "type": "boolean"
          },
          "info": {
            "description": "Metadata about the contract and author",
            "properties": {
              "license": {
                "description": "The license used by the contract, default is \"MIT\"",
                "type": "string"
              },
              "securityContact": {
                "description": "Email where people can contact you to report security issues. Will only be visible if contract source code is verified.",
                "type": "string"
              }
            },
            "type": "object"
          },
          "mintable": {
            "description": "Whether privileged accounts will be able to create more supply or emit more tokens",
            "type": "boolean"
          },
          "name": {
            "description": "The name of the contract",
            "type": "string"
          },
          "pausable": {
            "description": "Whether privileged accounts will be able to pause specifically marked functionality. Useful for emergency response.",
            "type": "boolean"
          },
          "supply": {
            "description": "Whether to keep track of total supply of tokens",
            "type": "boolean"
          },
          "updatableUri": {
            "description": "Whether privileged accounts will be able to set a new URI for all token types",
            "type": "boolean"
          },
          "upgradeable": {
            "anyOf": [
              {
                "const": "transparent",
                "type": "string"
              },
              {
                "const": "uups",
                "type": "string"
              }
            ],
            "description": "Whether the smart contract is upgradeable. Transparent uses more complex proxy with higher overhead, requires less changes in your contract. Can also be used with beacons. UUPS uses simpler proxy with less overhead, requires including extra code in your contract. Allows flexibility for authorizing upgrades."
          },
          "uri": {
            "description": "The location of the metadata for the token. Clients will replace any instance of {id} in this string with the tokenId.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "uri"
        ],
        "type": "object"
      },
      "name": "solidity-erc1155"
    },
    {
      "description": "Make a stablecoin token that uses the ERC-20 standard. Experimental, some features are not audited and are subject to change.\n\nReturns the source code of the generated contract, formatted in a Markdown code block. Does not write to disk.",
      "inputSchema": {
        "$schema": "http://json-schema.org/draft-07/schema#",
        "properties": {
          "access": {
            "anyOf": [
              {
                "anyOf": [
                  {
                    "const": "ownable",
                    "type": "string"
                  },
                  {
                    "const": "roles",
                    "type": "string"
                  }
                ]
              },
              {
                "const": "managed",
                "type": "string"
              }
            ],
            "description": "The type of access control to provision. Ownable is a simple mechanism with a single account authorized for all privileged actions. Roles is a flexible mechanism with a separate role for each privileged action. A role can have many authorized accounts. Managed enables a central contract to define a policy that allows certain callers to access certain functions."
          },
          "burnable": {
            "description": "Whether token holders will be able to destroy their tokens",
            "type": "boolean"
          },
          "callback": {
            "description": "Whether to include support for code execution after transfers and approvals on recipient contracts in a single transaction.",
            "type": "boolean"
          },
          "crossChainBridging": {
            "anyOf": [
              {
                "const": "custom",
                "type": "string"
              },
              {
                "const": "superchain",
                "type": "string"
              }
            ],
            "description": "Whether to allow authorized bridge contracts to mint and burn tokens for cross-chain transfers. Options are to use custom bridges on any chain, or the SuperchainERC20 standard with the predeployed SuperchainTokenBridge. The SuperchainERC20 feature is only available on chains in the Superchain, and requires deploying your contract to the same address on every chain in the Superchain."
          },
          "flashmint": {
            "description": "Whether to include built-in flash loans to allow lending tokens without requiring collateral as long as they're returned in the same transaction.",
            "type": "boolean"
          },
          "freezable": {
            "description": "Whether authorized accounts can freeze and unfreeze accounts for regulatory or security purposes. This feature is experimental, not audited and is subject to change.",
            "type": "boolean"
          },
          "info": {
            "description": "Metadata about the contract and author",
            "properties": {
              "license": {
                "description": "The license used by the contract, default is \"MIT\"",
                "type": "string"
              },
              "securityContact": {
                "description": "Email where people can contact you to report security issues. Will only be visible if contract source code is verified.",
                "type": "string"
              }
            },
            "type": "object"
          },
          "mintable": {
            "description": "Whether privileged accounts will be able to create more supply or emit more tokens",
            "type": "boolean"
          },
          "name": {
            "description": "The name of the contract",
            "type": "string"
          },
          "namespacePrefix": {
            "description": "The prefix for ERC-7201 namespace identifiers. It should be derived from the project name or a unique naming convention specific to the project. Used only if the contract includes storage variables and upgradeability is enabled. Default is \"myProject\".",
            "type": "string"
          },
          "pausable": {
            "description": "Whether privileged accounts will be able to pause specifically marked functionality. Useful for emergency response.",
            "type": "boolean"
          },
          "permit": {
            "description": "Whether without paying gas, token holders will be able to allow third parties to transfer from their account.",
            "type": "boolean"
          },
          "premint": {
            "description": "The number of tokens to premint for the deployer.",
            "type": "string"
          },
          "premintChainId": {
            "description": "The chain ID of the network on which to premint tokens.",
            "type": "string"
          },
          "restrictions": {
            "anyOf": [
              {
                "anyOf": [
                  {
                    "const": false,
                    "type": "boolean"
                  },
                  {
                    "const": "allowlist",
                    "type": "string"
                  }
                ]
              },
              {
                "const": "blocklist",
                "type": "string"
              }
            ],
            "description": "Whether to restrict certain users from transferring tokens, either via allowing or blocking them. This feature is experimental, not audited and is subject to change."
          },
          "symbol": {
            "description": "The short symbol for the token",
            "type": "string"
          },
          "votes": {
            "anyOf": [
              {
                "const": "blocknumber",
                "type": "string"
              },
              {
                "const": "timestamp",
                "type": "string"
              }
            ],
            "description": "Whether to keep track of historical balances for voting in on-chain governance. Voting durations can be expressed as block numbers or timestamps."
          }
        },
        "required": [
          "name",
          "symbol"
        ],
        "type": "object"
      },
      "name": "solidity-stablecoin"
    },
    {
      "description": "Make a real-world asset token that uses the ERC-20 standard. Experimental, some features are not audited and are subject to change.\n\nReturns the source code of the generated contract, formatted in a Markdown code block. Does not write to disk.",
      "inputSchema": {
        "$schema": "http://json-schema.org/draft-07/schema#",
        "properties": {
          "access": {
            "anyOf": [
              {
                "anyOf": [
                  {
                    "const": "ownable",
                    "type": "string"
                  },
                  {
                    "const": "roles",
                    "type": "string"
                  }
                ]
              },
              {
                "const": "managed",
                "type": "string"
              }
            ],
            "description": "The type of access control to provision. Ownable is a simple mechanism with a single account authorized for all privileged actions. Roles is a flexible mechanism with a separate role for each privileged action. A role can have many authorized accounts. Managed enables a central contract to define a policy that allows certain callers to access certain functions."
          },
          "burnable": {
            "description": "Whether token holders will be able to destroy their tokens",
            "type": "boolean"
          },
          "callback": {
            "description": "Whether to include support for code execution after transfers and approvals on recipient contracts in a single transaction.",
            "type": "boolean"
          },
          "crossChainBridging": {
            "anyOf": [
              {
                "const": "custom",
                "type": "string"
              },
              {
                "const": "superchain",
                "type": "string"
              }
            ],
            "description": "Whether to allow authorized bridge contracts to mint and burn tokens for cross-chain transfers. Options are to use custom bridges on any chain, or the SuperchainERC20 standard with the predeployed SuperchainTokenBridge. The SuperchainERC20 feature is only available on chains in the Superchain, and requires deploying your contract to the same address on every chain in the Superchain."
          },
          "flashmint": {
            "description": "Whether to include built-in flash loans to allow lending tokens without requiring collateral as long as they're returned in the same transaction.",
            "type": "boolean"
          },
          "freezable": {
            "description": "Whether authorized accounts can freeze and unfreeze accounts for regulatory or security purposes. This feature is experimental, not audited and is subject to change.",
            "type": "boolean"
          },
          "info": {
            "description": "Metadata about the contract and author",
            "properties": {
              "license": {
                "description": "The license used by the contract, default is \"MIT\"",
                "type": "string"
              },
              "securityContact": {
                "description": "Email where people can contact you to report security issues. Will only be visible if contract source code is verified.",
                "type": "string"
              }
            },
            "type": "object"
          },
          "mintable": {
            "description": "Whether privileged accounts will be able to create more supply or emit more tokens",
            "type": "boolean"
          },
          "name": {
            "description": "The name of the contract",
            "type": "string"
          },
          "namespacePrefix": {
            "description": "The prefix for ERC-7201 namespace identifiers. It should be derived from the project name or a unique naming convention specific to the project. Used only if the contract includes storage variables and upgradeability is enabled. Default is \"myProject\".",
            "type": "string"
          },
          "pausable": {
            "description": "Whether privileged accounts will be able to pause specifically marked functionality. Useful for emergency response.",
            "type": "boolean"
          },
          "permit": {
            "description": "Whether without paying gas, token holders will be able to allow third parties to transfer from their account.",
            "type": "boolean"
          },
          "premint": {
            "description": "The number of tokens to premint for the deployer.",
            "type": "string"
          },
          "premintChainId": {
            "description": "The chain ID of the network on which to premint tokens.",
            "type": "string"
          },
          "restrictions": {
            "anyOf": [
              {
                "anyOf": [
                  {
                    "const": false,
                    "type": "boolean"
                  },
                  {
                    "const": "allowlist",
                    "type": "string"
                  }
                ]
              },
              {
                "const": "blocklist",
                "type": "string"
              }
            ],
            "description": "Whether to restrict certain users from transferring tokens, either via allowing or blocking them. This feature is experimental, not audited and is subject to change."
          },
          "symbol": {
            "description": "The short symbol for the token",
            "type": "string"
          },
          "votes": {
            "anyOf": [
              {
                "const": "blocknumber",
                "type": "string"
              },
              {
                "const": "timestamp",
                "type": "string"
              }
            ],
            "description": "Whether to keep track of historical balances for voting in on-chain governance. Voting durations can be expressed as block numbers or timestamps."
          }
        },
        "required": [
          "name",
          "symbol"
        ],
        "type": "object"
      },
      "name": "solidity-rwa"
    },
    {
      "description": "Make an account contract that follows the ERC-4337 standard.\n\nReturns the source code of the generated contract, formatted in a Markdown code block. Does not write to disk.",
      "inputSchema": {
        "$schema": "http://json-schema.org/draft-07/schema#",
        "properties": {
          "ERC1155Holder": {
            "description": "Whether to implement the `onERC1155Received` function to allow the account to receive ERC1155 tokens.",
            "type": "boolean"
          },
          "ERC721Holder": {
            "description": "Whether to implement the `onERC721Received` function to allow the account to receive ERC721 tokens.",
            "type": "boolean"
          },
          "ERC7579Modules": {
            "anyOf": [
              {
                "anyOf": [
                  {
                    "const": false,
                    "type": "boolean"
                  },
                  {
                    "const": "AccountERC7579",
                    "type": "string"
                  }
                ]
              },
              {
                "const": "AccountERC7579Hooked",
                "type": "string"
              }
            ],
            "description": "Whether to implement the ERC-7579 compatibility to enable functionality on the account with modules."
          },
          "batchedExecution": {
            "description": "Whether to implement a minimal batching interface for the account to allow multiple operations to be executed in a single transaction following the ERC-7821 standard.",
            "type": "boolean"
          },
          "info": {
            "description": "Metadata about the contract and author",
            "properties": {
              "license": {
                "description": "The license used by the contract, default is \"MIT\"",
                "type": "string"
              },
              "securityContact": {
                "description": "Email where people can contact you to report security issues. Will only be visible if contract source code is verified.",
                "type": "string"
              }
            },
            "type": "object"
          },
          "name": {
            "description": "The name of the account contract",
            "type": "string"
          },
          "signatureValidation": {
            "anyOf": [
              {
                "anyOf": [
                  {
                    "const": false,
                    "type": "boolean"
                  },
                  {
                    "const": "ERC1271",
                    "type": "string"
                  }
                ]
              },
              {
                "const": "ERC7739",
                "type": "string"
              }
            ],
            "description": "Whether to implement the ERC-1271 standard for validating signatures. This is useful for the account to verify signatures."
          },
          "signer": {
            "anyOf": [
              {
                "anyOf": [
                  {
                    "anyOf": [
                      {
                        "anyOf": [
                          {
                            "anyOf": [
                              {
                                "anyOf": [
                                  {
                                    "anyOf": [
                                      {
                                        "const": false,
                                        "type": "boolean"
                                      },
                                      {
                                        "const": "ECDSA",
                                        "type": "string"
                                      }
                                    ]
                                  },
                                  {
                                    "const": "EIP7702",
                                    "type": "string"
                                  }
                                ]
                              },
                              {
                                "const": "Multisig",
                                "type": "string"
                              }
                            ]
                          },
                          {
                            "const": "MultisigWeighted",
                            "type": "string"
                          }
                        ]
                      },
                      {
                        "const": "P256",
                        "type": "string"
                      }
                    ]
                  },
                  {
                    "const": "RSA",
                    "type": "string"
                  }
                ]
              },
              {
                "const": "WebAuthn",
                "type": "string"
              }
            ],
            "description": "Defines the signature verification algorithm used by the account to verify user operations. Options:\n        - ECDSA: Standard Ethereum signature validation using secp256k1, validates signatures against a specified owner address\n        - EIP7702: Special ECDSA validation using account's own address as signer, enables EOAs to delegate execution rights\n        - Multisig: ERC-7913 multisignature requiring minimum number of signatures from authorized signers\n        - MultisigWeighted: ERC-7913 weighted multisignature where signers have different voting weights\n        - P256: NIST P-256 curve (secp256r1) validation for integration with Passkeys and HSMs\n        - RSA: RSA PKCS#1 v1.5 signature validation (RFC8017) for PKI systems and HSMs\n        - WebAuthn: Web Authentication (WebAuthn) assertion validation for integration with Passkeys and HSMs on top of P256"
          },
          "upgradeable": {
            "anyOf": [
              {
                "const": "transparent",
                "type": "string"
              },
              {
                "const": "uups",
                "type": "string"
              }
            ],
            "description": "Whether the smart contract is upgradeable. Transparent uses more complex proxy with higher overhead, requires less changes in your contract. Can also be used with beacons. UUPS uses simpler proxy with less overhead, requires including extra code in your contract. Allows flexibility for authorizing upgrades."
          }
        },
        "required": [
          "name"
        ],
        "type": "object"
      },
      "name": "solidity-account"
    },
    {
      "description": "Make a contract to implement governance, such as for a DAO.\n\nReturns the source code of the generated contract, formatted in a Markdown code block. Does not write to disk.",
      "inputSchema": {
        "$schema": "http://json-schema.org/draft-07/schema#",
        "properties": {
          "blockTime": {
            "description": "The block time of the chain, default is 12",
            "type": "number"
          },
          "clockMode": {
            "anyOf": [
              {
                "const": "blocknumber",
                "type": "string"
              },
              {
                "const": "timestamp",
                "type": "string"
              }
            ],
            "description": "The clock mode used by the voting token. For Governor, this must be chosen to match what the ERC20 or ERC721 voting token uses."
          },
          "decimals": {
            "description": "The number of decimals to use for the contract, default is 18 for ERC20Votes and 0 for ERC721Votes (because it does not apply to ERC721Votes)",
            "type": "number"
          },
          "delay": {
            "description": "The delay since proposal is created until voting starts, default is \"1 day\"",
            "type": "string"
          },
          "info": {
            "description": "Metadata about the contract and author",
            "properties": {
              "license": {
                "description": "The license used by the contract, default is \"MIT\"",
                "type": "string"
              },
              "securityContact": {
                "description": "Email where people can contact you to report security issues. Will only be visible if contract source code is verified.",
                "type": "string"
              }
            },
            "type": "object"
          },
          "name": {
            "description": "The name of the contract",
            "type": "string"
          },
          "period": {
            "description": "The length of period during which people can cast their vote, default is \"1 week\"",
            "type": "string"
          },
          "proposalThreshold": {
            "description": "Minimum number of votes an account must have to create a proposal, default is 0.",
            "type": "string"
          },
          "quorumAbsolute": {
            "description": "The absolute quorum required, in cases of quorumMode equals absolute",
            "type": "string"
          },
          "quorumMode": {
            "anyOf": [
              {
                "const": "percent",
                "type": "string"
              },
              {
                "const": "absolute",
                "type": "string"
              }
            ],
            "description": "The type of quorum mode to use"
          },
          "quorumPercent": {
            "description": "The percent required, in cases of quorumMode equals percent",
            "type": "number"
          },
          "settings": {
            "description": "Allow governance to update voting settings (delay, period, proposal threshold)",
            "type": "boolean"
          },
          "storage": {
            "description": "Enable storage of proposal details and enumerability of proposals",
            "type": "boolean"
          },
          "timelock": {
            "anyOf": [
              {
                "anyOf": [
                  {
                    "const": false,
                    "type": "boolean"
                  },
                  {
                    "const": "openzeppelin",
                    "type": "string"
                  }
                ]
              },
              {
                "const": "compound",
                "type": "string"
              }
            ],
            "description": "The type of timelock to use"
          },
          "upgradeable": {
            "anyOf": [
              {
                "const": "transparent",
                "type": "string"
              },
              {
                "const": "uups",
                "type": "string"
              }
            ],
            "description": "Whether the smart contract is upgradeable. Transparent uses more complex proxy with higher overhead, requires less changes in your contract. Can also be used with beacons. UUPS uses simpler proxy with less overhead, requires including extra code in your contract. Allows flexibility for authorizing upgrades."
          },
          "votes": {
            "anyOf": [
              {
                "const": "erc20votes",
                "type": "string"
              },
              {
                "const": "erc721votes",
                "type": "string"
              }
            ],
            "description": "The type of voting to use"
          }
        },
        "required": [
          "name",
          "delay",
          "period"
        ],
        "type": "object"
      },
      "name": "solidity-governor"
    },
    {
      "description": "Make a custom smart contract.\n\nReturns the source code of the generated contract, formatted in a Markdown code block. Does not write to disk.",
      "inputSchema": {
        "$schema": "http://json-schema.org/draft-07/schema#",
        "properties": {
          "access": {
            "anyOf": [
              {
                "anyOf": [
                  {
                    "const": "ownable",
                    "type": "string"
                  },
                  {
                    "const": "roles",
                    "type": "string"
                  }
                ]
              },
              {
                "const": "managed",
                "type": "string"
              }
            ],
            "description": "The type of access control to provision. Ownable is a simple mechanism with a single account authorized for all privileged actions. Roles is a flexible mechanism with a separate role for each privileged action. A role can have many authorized accounts. Managed enables a central contract to define a policy that allows certain callers to access certain functions."
          },
          "info": {
            "description": "Metadata about the contract and author",
            "properties": {
              "license": {
                "description": "The license used by the contract, default is \"MIT\"",
                "type": "string"
              },
              "securityContact": {
                "description": "Email where people can contact you to report security issues. Will only be visible if contract source code is verified.",
                "type": "string"
              }
            },
            "type": "object"
          },
          "name": {
            "description": "The name of the contract",
            "type": "string"
          },
          "pausable": {
            "description": "Whether privileged accounts will be able to pause specifically marked functionality. Useful for emergency response.",
            "type": "boolean"
          },
          "upgradeable": {
            "anyOf": [
              {
                "const": "transparent",
                "type": "string"
              },
              {
                "const": "uups",
                "type": "string"
              }
            ],
            "description": "Whether the smart contract is upgradeable. Transparent uses more complex proxy with higher overhead, requires less changes in your contract. Can also be used with beacons. UUPS uses simpler proxy with less overhead, requires including extra code in your contract. Allows flexibility for authorizing upgrades."
          }
        },
        "required": [
          "name"
        ],
        "type": "object"
      },
      "name": "solidity-custom"
    }
  ]
}
---

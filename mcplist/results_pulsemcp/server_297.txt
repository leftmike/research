NAME: com.exoquery/mcp-server
URL: https://backend.exoquery.com/mcp
TRANSPORT: streamable-http
AUTH_REQUIRED: no
STATUS: success
EXIT_CODE: 0
OUTPUT:
{
  "tools": [
    {
      "annotations": {
        "destructiveHint": true,
        "openWorldHint": true
      },
      "description": "\nAccess comprehensive ExoQuery documentation organized by topic and category.\n\nExoQuery is a Language Integrated Query library for Kotlin Multiplatform that translates Kotlin DSL expressions into SQL at compile time. This resource provides access to the complete documentation covering all aspects of the library.\n\nAVAILABLE DOCUMENTATION CATEGORIES:\n\n1. **Getting Started**\n   - Introduction: What ExoQuery is and why it exists\n   - Installation: Project setup and dependencies\n   - Quick Start: First query in minutes\n\n2. **Core Concepts**\n   - SQL Blocks: The sql { } construct and query building\n   - Parameters: Safe runtime data handling\n   - Composing Queries: Functional query composition\n\n3. **Query Operations**\n   - Basic Operations: Map, filter, and transformations\n   - Joins: Inner, left, and implicit joins\n   - Grouping: GROUP BY and HAVING clauses\n   - Sorting: ORDER BY operations\n   - Subqueries: Correlated and nested queries\n   - Window Functions: Advanced analytics\n\n4. **Actions**\n   - Insert: INSERT with returning and conflict handling\n   - Update: UPDATE operations with setParams\n   - Delete: DELETE with returning\n   - Batch Operations: Bulk inserts and updates\n\n5. **Advanced Features**\n   - SQL Fragment Functions: Reusable SQL components with @SqlFragment\n   - Dynamic Queries: Runtime query generation with @SqlDynamic\n   - Free Blocks: Custom SQL and user-defined functions\n   - Transactions: Transaction support patterns\n   - Polymorphic Queries: Interfaces, sealed classes, higher-order functions\n   - Local Variables: Variables within SQL blocks\n\n6. **Data Handling**\n   - Serialization: kotlinx.serialization integration\n   - Custom Type Encoding: Custom encoders and decoders\n   - JSON Columns: JSON and JSONB support (PostgreSQL)\n   - Column Naming: @SerialName and @ExoEntity annotations\n   - Nested Datatypes: Complex data structures\n   - Kotlinx Integration: JSON and other serialization formats\n\n7. **Schema-First Development**\n   - Entity Generation: Compile-time code generation from database schema\n   - AI-Enhanced Entities: Using LLMs to generate cleaner entity code\n\n8. **Reference**\n   - SQL Functions: Available string, math, and date functions\n   - API Reference: Core types and function signatures\n\nHOW TO USE THIS RESOURCE:\n\nThe resource URI follows the pattern:\n  exoquery://docs/{file-path}\n\nWhere {file-path} is the relative path from the docs root, e.g.:\n  - exoquery://docs/01-getting-started/01-introduction.md\n  - exoquery://docs/03-query-operations/02-joins.md\n  - exoquery://docs/05-advanced-features/01-sql-fragments.md\n\nTo discover available documents, use the MCP resources/list endpoint which will return all available documentation files with their titles, descriptions, and categories.\n\nEach document includes:\n- Title and description\n- Category classification\n- Complete markdown content with code examples\n- Cross-references to related topics\n\nWHEN TO USE:\n- User asks about ExoQuery syntax, features, or capabilities\n- User needs examples of specific query patterns\n- User encounters errors and needs to verify correct usage\n- User wants to understand advanced features or best practices\n",
      "inputSchema": {
        "properties": {
          "filePath": {
            "description": "\nThe documentation file path to retrieve.\n\nFormat: Relative path from docs root (e.g., \"01-getting-started/01-introduction.md\")\n\nThe full URI is: exoquery://docs/{file-path}\n\nTo find available file paths, use the MCP resources/list endpoint which returns metadata for all documentation files including their paths, titles, categories, and descriptions.\n\nCommon paths:\n- Getting Started: 01-getting-started/01-introduction.md, 01-getting-started/02-installation.md, 01-getting-started/03-quick-start.md\n- Core Concepts: 02-core-concepts/01-sql-blocks.md, 02-core-concepts/02-parameters.md, 02-core-concepts/03-composing-queries.md\n- Query Operations: 03-query-operations/01-basic-operations.md, 03-query-operations/02-joins.md, 03-query-operations/03-grouping.md\n- Actions: 04-actions/01-insert.md, 04-actions/02-update.md, 04-actions/03-delete.md\n- Advanced: 05-advanced-features/01-sql-fragments.md, 05-advanced-features/02-dynamic-queries.md\n- Data Handling: 06-data-handling/03-json-columns.md, 06-data-handling/04-column-naming.md\n",
            "type": "string"
          }
        },
        "required": [
          "filePath"
        ],
        "type": "object"
      },
      "name": "getExoQueryDocs",
      "title": "getExoQueryDocs"
    },
    {
      "annotations": {
        "destructiveHint": true,
        "openWorldHint": true
      },
      "description": "\nAccess multiple ExoQuery documentation sections simultaneously.\n\nThis tool is similar to the single-document retrieval tool but allows fetching multiple documentation files in a single request. This is particularly useful when you need to gather information from several related topics at once.\n\nExoQuery is a Language Integrated Query library for Kotlin Multiplatform that translates Kotlin DSL expressions into SQL at compile time. This resource provides access to the complete documentation covering all aspects of the library.\n\nHOW TO USE THIS RESOURCE:\n\nProvide a list of file paths, where each path is the relative path from the docs root, e.g.:\n  - 01-getting-started/01-introduction.md\n  - 03-query-operations/02-joins.md\n  - 05-advanced-features/01-sql-fragments.md\n\nTo discover available documents, use the MCP resources/list endpoint which will return all available documentation files with their titles, descriptions, and categories.\n\nEach returned document includes:\n- Title and description\n- Category classification\n- Complete markdown content with code examples\n- Cross-references to related topics\n\nWHEN TO USE:\n- User asks about multiple ExoQuery topics that require information from different sections\n- User needs to compare or understand relationships between different features\n- User wants to get comprehensive information across multiple categories\n- More efficient than making multiple single-document requests\n",
      "inputSchema": {
        "properties": {
          "filePaths": {
            "description": "\nA list of documentation file paths to retrieve.\n\nFormat: List of relative paths from docs root (e.g., [\"01-getting-started/01-introduction.md\", \"03-query-operations/02-joins.md\"])\n\nEach path follows the pattern used in single-document retrieval: {category-folder}/{file-name}.md\n\nTo find available file paths, use the MCP resources/list endpoint which returns metadata for all documentation files including their paths, titles, categories, and descriptions.\n\nCommon paths:\n- Getting Started: 01-getting-started/01-introduction.md, 01-getting-started/02-installation.md, 01-getting-started/03-quick-start.md\n- Core Concepts: 02-core-concepts/01-sql-blocks.md, 02-core-concepts/02-parameters.md, 02-core-concepts/03-composing-queries.md\n- Query Operations: 03-query-operations/01-basic-operations.md, 03-query-operations/02-joins.md, 03-query-operations/03-grouping.md\n- Actions: 04-actions/01-insert.md, 04-actions/02-update.md, 04-actions/03-delete.md\n- Advanced: 05-advanced-features/01-sql-fragments.md, 05-advanced-features/02-dynamic-queries.md\n- Data Handling: 06-data-handling/03-json-columns.md, 06-data-handling/04-column-naming.md\n",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "required": [
          "filePaths"
        ],
        "type": "object"
      },
      "name": "getExoQueryDocsMulti",
      "title": "getExoQueryDocsMulti"
    },
    {
      "annotations": {
        "destructiveHint": true,
        "openWorldHint": true
      },
      "description": "Lists all available ExoQuery documentation resources with their metadata",
      "inputSchema": {
        "properties": {},
        "required": [],
        "type": "object"
      },
      "name": "listExoQueryDocs",
      "title": "listExoQueryDocs"
    },
    {
      "annotations": {
        "destructiveHint": true,
        "openWorldHint": true
      },
      "description": "\nExecute raw, client-provided SQL queries against an ephemeral database initialized with the provided schema.\nReturns query results in a simple JSON format with column headers and row data as a 2D array.\n\nThe database type (SQLite or Postgres) is specified via the databaseType parameter:\n- SQLITE: In-memory, lightweight, uses standard SQLite syntax\n- POSTGRES: Temporary isolated schema with dedicated user, uses PostgreSQL syntax and features\n\nWHEN TO USE: When you need to run your own hand-written SQL queries to test database behavior or\ncompare the output with ExoQuery results from validateAndRunExoquery. This lets you verify that\nExoQuery-generated SQL produces the same results as your expected SQL.\n\nINPUT REQUIREMENTS:\n- query: A valid SQL query (SELECT, INSERT, UPDATE, DELETE, etc.)\n- schema: SQL schema with CREATE TABLE and INSERT statements to initialize the test database\n- databaseType: Either \"SQLITE\" or \"POSTGRES\" (defaults to SQLITE if not specified)\n\nOUTPUT FORMAT:\n\nOn success, returns JSON with the SQL query and a 2D array of results:\n{\"sql\":\"SELECT * FROM users ORDER BY id\",\"output\":[[\"id\",\"name\",\"age\"],[\"1\",\"Alice\",\"30\"],[\"2\",\"Bob\",\"25\"],[\"3\",\"Charlie\",\"35\"]]}\n\nOutput format details:\n- First array element contains column headers\n- Subsequent array elements contain row data\n- All values are returned as strings\n\nOn error, returns JSON with error message and the attempted query (if available):\n{\"error\":\"Query execution failed: no such table: USERS\",\"sql\":\"SELECT * FROM USERS\"}\n\nOr if schema initialization fails:\n{\"error\":\"Database initialization failed due to: near \\\"CREAT\\\": syntax error\\\\nWhen executing the following statement:\\\\n--------\\\\nCREAT TABLE users ...\\\\n--------\",\"sql\":\"CREAT TABLE users ...\"}\n\nEXAMPLE INPUT:\n\nQuery:\nSELECT * FROM users ORDER BY id\n\nSchema:\nCREATE TABLE users (\n  id INTEGER PRIMARY KEY,\n  name TEXT NOT NULL,\n  age INTEGER\n);\n\nINSERT INTO users (id, name, age) VALUES (1, 'Alice', 30);\nINSERT INTO users (id, name, age) VALUES (2, 'Bob', 25);\nINSERT INTO users (id, name, age) VALUES (3, 'Charlie', 35);\n\nEXAMPLE SUCCESS OUTPUT:\n{\"sql\":\"SELECT * FROM users ORDER BY id\",\"output\":[[\"id\",\"name\",\"age\"],[\"1\",\"Alice\",\"30\"],[\"2\",\"Bob\",\"25\"],[\"3\",\"Charlie\",\"35\"]]}\n\nEXAMPLE ERROR OUTPUT (bad table name):\n{\"error\":\"Query execution failed: no such table: invalid_table\",\"sql\":\"SELECT * FROM invalid_table\"}\n\nEXAMPLE ERROR OUTPUT (bad schema):\n{\"error\":\"Database initialization failed due to: near \\\"CREAT\\\": syntax error\\\\nWhen executing the following statement:\\\\n--------\\\\nCREAT TABLE users (id INTEGER)\\\\n--------\\\\nCheck that the initialization SQL is valid and compatible with SQLite.\",\"sql\":\"CREAT TABLE users (id INTEGER)\"}\n\nCOMMON QUERY EXAMPLES:\n\nSelect all rows:\nSELECT * FROM users\n\nSelect specific columns with filtering:\nSELECT name, age FROM users WHERE age \u003e 25\n\nAggregate functions:\nSELECT COUNT(*) as total FROM users\n\nJoin queries:\nSELECT u.name, o.total FROM users u JOIN orders o ON u.id = o.user_id\n\nInsert data:\nINSERT INTO users (name, age) VALUES ('David', 40)\n\nUpdate data:\nUPDATE users SET age = 31 WHERE name = 'Alice'\n\nDelete data:\nDELETE FROM users WHERE age \u003c 25\n\nCount with grouping:\nSELECT age, COUNT(*) as count FROM users GROUP BY age\n\nSCHEMA RULES:\n- Use standard SQLite syntax\n- Table names are case-sensitive (use lowercase for simplicity or quote names)\n- Include INSERT statements to populate test data for meaningful results\n- Supported data types: INTEGER, TEXT, REAL, BLOB, NULL\n- Use INTEGER PRIMARY KEY for auto-increment columns\n- Schema SQL is split on semicolons (;), so each statement after a ';' is executed separately\n- Avoid semicolons in comments as they will cause statement parsing issues\n\nCOMPARISON WITH EXOQUERY:\nThis tool is designed to work alongside validateAndRunExoquery for comparison purposes:\n1. Use validateAndRunExoquery to run ExoQuery Kotlin code and see the generated SQL + results\n2. Use runRawSql with your own hand-written SQL to verify you get the same output\n3. Compare the outputs to ensure ExoQuery generates the SQL you expect\n4. Test edge cases with plain SQL before writing equivalent ExoQuery code\n",
      "inputSchema": {
        "properties": {
          "query": {
            "description": "\nA valid SQL query to execute against the database.\n\nCan be any valid SQL statement (syntax depends on databaseType parameter):\n- SELECT queries (with WHERE, JOIN, GROUP BY, ORDER BY, LIMIT, etc.)\n- INSERT statements\n- UPDATE statements\n- DELETE statements\n- DDL statements like CREATE/ALTER/DROP (applied after schema initialization)\n\nThe query will be executed against a database initialized with the provided schema parameter.\n\nExample:\nSELECT * FROM users WHERE age \u003e 25 ORDER BY name\n",
            "type": "string"
          },
          "schema": {
            "description": "\nSQL schema to initialize the ephemeral test database.\n\nMust include:\n1. CREATE TABLE statements for all tables used in the query\n2. INSERT statements with test data\n\nUse syntax appropriate for the selected databaseType (SQLite or Postgres).\nTable names are case-sensitive. The schema is split on semicolons, so each statement is executed separately.\n\nExample:\nCREATE TABLE users (\n  id INTEGER PRIMARY KEY,\n  name TEXT NOT NULL,\n  age INTEGER\n);\n\nINSERT INTO users (id, name, age) VALUES (1, 'Alice', 30);\nINSERT INTO users (id, name, age) VALUES (2, 'Bob', 25);\nINSERT INTO users (id, name, age) VALUES (3, 'Charlie', 35);\n",
            "type": "string"
          }
        },
        "required": [
          "query",
          "schema"
        ],
        "type": "object"
      },
      "name": "runRawSql",
      "title": "runRawSql"
    },
    {
      "annotations": {
        "destructiveHint": true,
        "openWorldHint": true
      },
      "description": "\nCompile ExoQuery Kotlin code and EXECUTE it against an Sqlite database with provided schema.\nExoQuery is a compile-time SQL query builder that translates Kotlin DSL expressions into SQL.\n\nWHEN TO USE: When you need to verify ExoQuery produces correct results against actual data.\n\nINPUT REQUIREMENTS:\n- Complete Kotlin code (same requirements as validateExoquery)\n- SQL schema with CREATE TABLE and INSERT statements for test data\n- Data classes MUST exactly match the schema table structure\n- Column names in data classes must match schema (use @SerialName for snake_case columns)\n- Must include or or more .runSample() calls in main() to trigger SQL generation and execution\n  (note that .runSample() is NOT or real production use, use .runOn(database) instead)\n  \n\nOUTPUT FORMAT:\n\nReturns one or more JSON objects, each on its own line. Each object can be:\n\n1. SQL with output (query executed successfully):\n   {\"sql\": \"SELECT u.name FROM \\\"User\\\" u\", \"output\": \"[(name=Alice), (name=Bob)]\"}\n\n2. Output only (e.g., print statements, intermediate results):\n   {\"output\": \"Before: [(id=1, title=Ion Blend Beans)]\"}\n\n3. Error output (runtime errors, exceptions):\n   {\"outputErr\": \"java.sql.SQLException: Table \\\"USERS\\\" not found\"}\n\nMultiple results appear when code has multiple queries or print statements:\n\n{\"sql\": \"SELECT * FROM \\\"InventoryItem\\\"\", \"output\": \"[(id=1, title=Ion Blend Beans, unit_price=32.00, in_stock=25)]\"}\n{\"output\": \"Before:\"}\n{\"sql\": \"INSERT INTO \\\"InventoryItem\\\" (title, unit_price, in_stock) VALUES (?, ?, ?)\", \"output\": \"Rows affected: 1\"}\n{\"output\": \"After:\"}\n{\"sql\": \"SELECT * FROM \\\"InventoryItem\\\"\", \"output\": \"[(id=1, title=Ion Blend Beans, unit_price=32.00, in_stock=25), (id=2, title=Luna Fuel Flask, unit_price=89.50, in_stock=6)]\"}\n\nCompilation errors return the same format as validateExoquery:\n{\n  \"errors\": {\n    \"File.kt\": [\n      {\n        \"interval\": {\"start\": {\"line\": 12, \"ch\": 10}, \"end\": {\"line\": 12, \"ch\": 15}},\n        \"message\": \"Type mismatch: inferred type is String but Int was expected\",\n        \"severity\": \"ERROR\",\n        \"className\": \"ERROR\"\n      }\n    ]\n  }\n}\n\nRuntime Errors can have the following format:\n{\n  \"errors\" : {\n    \"File.kt\" : [ ]\n  },\n  \"exception\" : {\n    \"message\" : \"[SQLITE_ERROR] SQL error or missing database (no such table: User)\",\n    \"fullName\" : \"org.sqlite.SQLiteException\",\n    \"stackTrace\" : [ {\n      \"className\" : \"org.sqlite.core.DB\",\n      \"methodName\" : \"newSQLException\",\n      \"fileName\" : \"DB.java\",\n      \"lineNumber\" : 1179\n    }, ...]\n  },\n  \"text\" : \"\u003coutStream\u003e\u003coutputObject\u003e\\n{\\\"sql\\\": \\\"SELECT x.id, x.name, x.age FROM User x\\\"}\\n\u003c/outputObject\u003e\\n\u003c/outStream\u003e\"\n}\nIf there was a SQL query generated before the error, it will appear in the \"text\" field output stream.\n\n\nEXAMPLE INPUT CODE:\n```kotlin\nimport io.exoquery.*\nimport kotlinx.serialization.Serializable\nimport kotlinx.serialization.SerialName\n\n@Serializable\ndata class User(val id: Int, val name: String, val age: Int)\n\n@Serializable\ndata class Order(val id: Int, @SerialName(\"user_id\") val userId: Int, val total: Int)\n\nval userOrders = sql.select {\n    val u = from(Table\u003cUser\u003e())\n    val o = join(Table\u003cOrder\u003e()) { o -\u003e o.userId == u.id }\n    Triple(u.name, o.total, u.age)\n}\n\nfun main() = userOrders.buildPrettyFor.Sqlite().runSample()\n```\n\nEXAMPLE INPUT SCHEMA:\n```sql\nCREATE TABLE \"User\" (id INT, name VARCHAR(100), age INT);\nCREATE TABLE \"Order\" (id INT, user_id INT, total INT);\n\nINSERT INTO \"User\" (id, name, age) VALUES\n  (1, 'Alice', 30),\n  (2, 'Bob', 25);\n\nINSERT INTO \"Order\" (id, user_id, total) VALUES\n  (1, 1, 100),\n  (2, 1, 200),\n  (3, 2, 150);\n```\n\nEXAMPLE SUCCESS OUTPUT:\n{\"sql\": \"SELECT u.name AS first, o.total AS second, u.age AS third FROM \\\"User\\\" u INNER JOIN \\\"Order\\\" o ON o.user_id = u.id\", \"output\": \"[(first=Alice, second=100, third=30), (first=Alice, second=200, third=30), (first=Bob, second=150, third=25)]\"}\n\nEXAMPLE WITH MULTIPLE OPERATIONS (insert with before/after check):\n{\"output\": \"Before:\"}\n{\"sql\": \"SELECT * FROM \\\"InventoryItem\\\"\", \"output\": \"[(id=1, title=Ion Blend Beans)]\"}\n{\"sql\": \"INSERT INTO \\\"InventoryItem\\\" (title, unit_price, in_stock) VALUES (?, ?, ?)\", \"output\": \"\"}\n{\"output\": \"After:\"}\n{\"sql\": \"SELECT * FROM \\\"InventoryItem\\\"\", \"output\": \"[(id=1, title=Ion Blend Beans), (id=2, title=Luna Fuel Flask)]\"}\n\nEXAMPLE RUNTIME ERROR (if a user divided by zero):\n{\"outputErr\": \"Exception in thread \"main\" java.lang.ArithmeticException: / by zero\"}\n\nKEY PATTERNS:\n\n(See validateExoquery for complete pattern reference)\n\nSummary of most common patterns:\n- Filter: sql { Table\u003cT\u003e().filter { x -\u003e x.field == value } }\n- Select: sql.select { val x = from(Table\u003cT\u003e()); where { ... }; x }\n- Join: sql.select { val a = from(Table\u003cA\u003e()); val b = join(Table\u003cB\u003e()) { b -\u003e b.aId == a.id }; Pair(a, b) }\n- Left join: joinLeft(Table\u003cT\u003e()) { ... } returns nullable\n- Insert: sql { insert\u003cT\u003e { setParams(obj).excluding(id) } }\n- Update: sql { update\u003cT\u003e().set { it.field to value }.where { it.id == x } }\n- Delete: sql { delete\u003cT\u003e().where { it.id == x } }\n\nSCHEMA RULES:\n- Table names should match data class names (case-sensitive, use quotes for exact match)\n- Column names must match @SerialName values or property names\n- Include realistic test data to verify query logic\n- Sqlite database syntax (mostly compatible with standard SQL)\n\nCOMMON PATTERNS:\n- JSON columns: Use VARCHAR for storage, @SqlJsonValue on the nested data class\n- Auto-increment IDs: Use INTEGER PRIMARY KEY\n- Nullable columns: Use Type? in Kotlin, allow NULL in schema\n",
      "inputSchema": {
        "properties": {
          "code": {
            "description": "\nComplete ExoQuery Kotlin code to compile and execute.\n\nMust include:\n1. Imports (minimum: io.exoquery.*, kotlinx.serialization.Serializable)\n2. @Serializable data classes that EXACTLY match your schema tables\n3. The query expression\n4. A main() function ending with .buildFor.\u003cDialect\u003e().runSample()\n    This function MUST be present to trigger SQL generation and execution.\n\nUse @SerialName(\"column_name\") when Kotlin property names differ from SQL column names.\nUse @Contextual for BigDecimal fields.\nUse @SqlJsonValue on data classes that represent JSON column values.\n\nMultiple queries in main() will produce multiple output JSON objects.\n",
            "type": "string"
          },
          "databaseType": {
            "description": "Database type: SQLITE or POSTGRES (default: SQLITE)",
            "type": "string"
          },
          "schema": {
            "description": "\nSQL schema to initialize the Sqlite test database.\n\nMust include:\n1. CREATE TABLE statements for all tables referenced in the query\n2. INSERT statements with test data to verify query behavior\n\nTable and column names must exactly match the data classes in the code.\nUse double quotes around table names to preserve case: CREATE TABLE \"User\" (...)\n\nCommon error: Table \"USER\" not found, means you wrote CREATE TABLE User but queried \"User\".\nAlways quote table names in schema to match ExoQuery's generated SQL.\n\nExample:\nCREATE TABLE \"User\" (id INT, name VARCHAR(100), age INT);\nINSERT INTO \"User\" VALUES (1, 'Alice', 30), (2, 'Bob', 25);\n",
            "type": "string"
          }
        },
        "required": [
          "code",
          "schema"
        ],
        "type": "object"
      },
      "name": "validateAndRunExoquery",
      "title": "validateAndRunExoquery"
    },
    {
      "annotations": {
        "destructiveHint": true,
        "openWorldHint": true
      },
      "description": "\nCompile ExoQuery Kotlin code and EXECUTE it against an Sqlite database with provided schema.\nExoQuery is a compile-time SQL query builder that translates Kotlin DSL expressions into SQL.\n\nWHEN TO USE: When you need to verify ExoQuery produces correct results against actual data.\n\nINPUT REQUIREMENTS:\n- Complete Kotlin code (same requirements as validateExoquery)\n- SQL schema with CREATE TABLE and INSERT statements for test data\n- Data classes MUST exactly match the schema table structure\n- Column names in data classes must match schema (use @SerialName for snake_case columns)\n- Must include or or more .runSample() calls in main() to trigger SQL generation and execution\n  (note that .runSample() is NOT or real production use, use .runOn(database) instead)\n  \n\nOUTPUT FORMAT:\n\nReturns one or more JSON objects, each on its own line. Each object can be:\n\n1. SQL with output (query executed successfully):\n   {\"sql\": \"SELECT u.name FROM \\\"User\\\" u\", \"output\": \"[(name=Alice), (name=Bob)]\"}\n\n2. Output only (e.g., print statements, intermediate results):\n   {\"output\": \"Before: [(id=1, title=Ion Blend Beans)]\"}\n\n3. Error output (runtime errors, exceptions):\n   {\"outputErr\": \"java.sql.SQLException: Table \\\"USERS\\\" not found\"}\n\nMultiple results appear when code has multiple queries or print statements:\n\n{\"sql\": \"SELECT * FROM \\\"InventoryItem\\\"\", \"output\": \"[(id=1, title=Ion Blend Beans, unit_price=32.00, in_stock=25)]\"}\n{\"output\": \"Before:\"}\n{\"sql\": \"INSERT INTO \\\"InventoryItem\\\" (title, unit_price, in_stock) VALUES (?, ?, ?)\", \"output\": \"Rows affected: 1\"}\n{\"output\": \"After:\"}\n{\"sql\": \"SELECT * FROM \\\"InventoryItem\\\"\", \"output\": \"[(id=1, title=Ion Blend Beans, unit_price=32.00, in_stock=25), (id=2, title=Luna Fuel Flask, unit_price=89.50, in_stock=6)]\"}\n\nCompilation errors return the same format as validateExoquery:\n{\n  \"errors\": {\n    \"File.kt\": [\n      {\n        \"interval\": {\"start\": {\"line\": 12, \"ch\": 10}, \"end\": {\"line\": 12, \"ch\": 15}},\n        \"message\": \"Type mismatch: inferred type is String but Int was expected\",\n        \"severity\": \"ERROR\",\n        \"className\": \"ERROR\"\n      }\n    ]\n  }\n}\n\nRuntime Errors can have the following format:\n{\n  \"errors\" : {\n    \"File.kt\" : [ ]\n  },\n  \"exception\" : {\n    \"message\" : \"[SQLITE_ERROR] SQL error or missing database (no such table: User)\",\n    \"fullName\" : \"org.sqlite.SQLiteException\",\n    \"stackTrace\" : [ {\n      \"className\" : \"org.sqlite.core.DB\",\n      \"methodName\" : \"newSQLException\",\n      \"fileName\" : \"DB.java\",\n      \"lineNumber\" : 1179\n    }, ...]\n  },\n  \"text\" : \"\u003coutStream\u003e\u003coutputObject\u003e\\n{\\\"sql\\\": \\\"SELECT x.id, x.name, x.age FROM User x\\\"}\\n\u003c/outputObject\u003e\\n\u003c/outStream\u003e\"\n}\nIf there was a SQL query generated before the error, it will appear in the \"text\" field output stream.\n\n\nEXAMPLE INPUT CODE:\n```kotlin\nimport io.exoquery.*\nimport kotlinx.serialization.Serializable\nimport kotlinx.serialization.SerialName\n\n@Serializable\ndata class User(val id: Int, val name: String, val age: Int)\n\n@Serializable\ndata class Order(val id: Int, @SerialName(\"user_id\") val userId: Int, val total: Int)\n\nval userOrders = sql.select {\n    val u = from(Table\u003cUser\u003e())\n    val o = join(Table\u003cOrder\u003e()) { o -\u003e o.userId == u.id }\n    Triple(u.name, o.total, u.age)\n}\n\nfun main() = userOrders.buildPrettyFor.Sqlite().runSample()\n```\n\nEXAMPLE INPUT SCHEMA:\n```sql\nCREATE TABLE \"User\" (id INT, name VARCHAR(100), age INT);\nCREATE TABLE \"Order\" (id INT, user_id INT, total INT);\n\nINSERT INTO \"User\" (id, name, age) VALUES\n  (1, 'Alice', 30),\n  (2, 'Bob', 25);\n\nINSERT INTO \"Order\" (id, user_id, total) VALUES\n  (1, 1, 100),\n  (2, 1, 200),\n  (3, 2, 150);\n```\n\nEXAMPLE SUCCESS OUTPUT:\n{\"sql\": \"SELECT u.name AS first, o.total AS second, u.age AS third FROM \\\"User\\\" u INNER JOIN \\\"Order\\\" o ON o.user_id = u.id\", \"output\": \"[(first=Alice, second=100, third=30), (first=Alice, second=200, third=30), (first=Bob, second=150, third=25)]\"}\n\nEXAMPLE WITH MULTIPLE OPERATIONS (insert with before/after check):\n{\"output\": \"Before:\"}\n{\"sql\": \"SELECT * FROM \\\"InventoryItem\\\"\", \"output\": \"[(id=1, title=Ion Blend Beans)]\"}\n{\"sql\": \"INSERT INTO \\\"InventoryItem\\\" (title, unit_price, in_stock) VALUES (?, ?, ?)\", \"output\": \"\"}\n{\"output\": \"After:\"}\n{\"sql\": \"SELECT * FROM \\\"InventoryItem\\\"\", \"output\": \"[(id=1, title=Ion Blend Beans), (id=2, title=Luna Fuel Flask)]\"}\n\nEXAMPLE RUNTIME ERROR (if a user divided by zero):\n{\"outputErr\": \"Exception in thread \"main\" java.lang.ArithmeticException: / by zero\"}\n\nKEY PATTERNS:\n\n(See validateExoquery for complete pattern reference)\n\nSummary of most common patterns:\n- Filter: sql { Table\u003cT\u003e().filter { x -\u003e x.field == value } }\n- Select: sql.select { val x = from(Table\u003cT\u003e()); where { ... }; x }\n- Join: sql.select { val a = from(Table\u003cA\u003e()); val b = join(Table\u003cB\u003e()) { b -\u003e b.aId == a.id }; Pair(a, b) }\n- Left join: joinLeft(Table\u003cT\u003e()) { ... } returns nullable\n- Insert: sql { insert\u003cT\u003e { setParams(obj).excluding(id) } }\n- Update: sql { update\u003cT\u003e().set { it.field to value }.where { it.id == x } }\n- Delete: sql { delete\u003cT\u003e().where { it.id == x } }\n\nSCHEMA RULES:\n- Table names should match data class names (case-sensitive, use quotes for exact match)\n- Column names must match @SerialName values or property names\n- Include realistic test data to verify query logic\n- Sqlite database syntax (mostly compatible with standard SQL)\n\nCOMMON PATTERNS:\n- JSON columns: Use VARCHAR for storage, @SqlJsonValue on the nested data class\n- Auto-increment IDs: Use INTEGER PRIMARY KEY\n- Nullable columns: Use Type? in Kotlin, allow NULL in schema\n",
      "inputSchema": {
        "properties": {
          "code": {
            "description": "\nComplete ExoQuery Kotlin code to compile.\n\nMust include:\n1. Imports (minimum: io.exoquery.*, kotlinx.serialization.Serializable)\n2. @Serializable data classes matching your query entities\n3. The query expression using sql { ... } or sql.select { ... }\n4. A main() function ending with .buildFor.\u003cDialect\u003e().runSample() or .buildPrettyFor.\u003cDialect\u003e().runSample()\n   This function MUST be present to trigger SQL generation.\n\nThe runSample() function triggers SQL generation but does NOT execute the query for validateExoquery.\n(Note that this is NOT for production ExoQuery usage. For that you use `.runOn(database)`.)\n\nDialect is part of the code (e.g., .buildFor.Postgres()), NOT a separate parameter.\n\nIf compilation fails, check the error interval positions to locate the exact issue in your code.\n",
            "type": "string"
          }
        },
        "required": [
          "code"
        ],
        "type": "object"
      },
      "name": "validateExoquery",
      "title": "validateExoquery"
    }
  ]
}
---
